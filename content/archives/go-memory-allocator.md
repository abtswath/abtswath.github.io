---
title: "Go 内存管理"
date: 2022-10-21T17:16:23+08:00
draft: false
categories: 笔记
tags: 
    Go
---

## 内存分配策略

### 链表空间分配器之隔离适应策略

将内存分为多个内存块相同的链表，分配内存时先找到符合要求的链表，再去链表中找到合适的内存块。

### 多级缓存

线程缓存、中心缓存、页堆。32KB 以下的对象，选择线程缓存，线程缓存不能满足需求时，将对象分配到中心缓存；32KB 以上的对象，选择页堆。

线程缓存属于每一个线程，不涉及多线程访问，不需要互斥锁；访问中心缓存需要互斥锁。

### 内存分配

#### 根据对象类型（微对象、小对象、大对象）不同，选择不同分配策略

* 微对象 `(0, 16B)` - 先使用微型分配器，再依次尝试线程缓存、中心缓存和堆分配内存。
* 小对象 `(16B, 32KB)` - 依次尝试使用线程缓存、中心缓存和堆分配内存。
* 大对象 `(32KB,)` - 直接在堆上分配内存。

#### 微对象

使用线程缓存上的微分配器提高微对象分配的性能，主要用来分配较小的字符串以及逃逸的临时变量。将多个较小的内存分配合并到一个内存块上，直到内存块中所有的对象都需要被回收时，内存块才会被回收。

微型分配器管理的对象不可以是指针类型。

### 小对象

16B ~ 32KB 大小的对象以及小于 16B 的指针类型对象。首先确定分配对象的大小及跨度类，再依次从线程缓存、中心缓存或者堆中获取内存管理单元并从内存管理单元找到空闲的内存空间。

#### 大对象

计算该对象所需页数，按照 8KB 的倍数在堆上申请内存。

## 垃圾回收

### Go1.3 前的标记 - 清除算法

* 标记：从根对象出发查找并标记堆中所有存活的对象；
* 清除：遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。

#### 缺点

* 需要 STW (Stop the world)，让程序暂停，程序出现卡顿；
* 需要扫描整个堆；
* 清除数据会产生堆碎片。

### Go1.5 三色标记法

#### 把对象分为白色、灰色、黑色三种类型

* 白色对象：潜在的垃圾对象，其内存可能会被回收；
* 黑色对象：活跃对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象；
* 灰色对象：活跃对象，存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象。

#### 执行过程

* 从根节点遍历所有对象，从白色对象的集合中取出一个对象将其标记为灰色；
* 遍历灰色对象集合，从灰色集合中取出一个对象并将其引用的对象标记为灰色，将其本身标记为黑色；
* 重复第三步，直至灰色对象集合中无任何对象；
* 回收白色对象集合中所有的对象。

在并发或增量执行时如果 STW 会影响性能，否则会产生悬挂指针，即没有任何指针指向该对象，影响内存安全性。想要并发或增量标记对象需要使用屏障技术。

### 屏障技术

### 三色标记混合写屏障

### 总结

* Go1.3：普通标记清除法：逻辑简单，但启动时需要 STW，效率极低；
* Go1.5：三色标记法：堆空间启动写屏障，栈空间不启动，全部扫描之后，需要再次扫描栈空间（需要 STW），效率一般；
* Go1.8：三色标记混合写屏障：栈空间不启动，堆空间启动，几乎不用 STW，效率高。
