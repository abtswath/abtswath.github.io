---
title: "GMP 模型与调度过程"
date: 2022-10-21T16:20:35+08:00
draft: false
url: goroutine
categories: 笔记
tags: 
  - Go
---

## GMP模型

### G

Goroutine 是 Go 语言调度器中待执行的任务，类似操作系统中的线程，但占用内存低且上下文切换开销小。

### M

Machine 指操作系统线程。调度器最多创建 10000 个线程，但最多只会有 GOMAXPROCS 个线程处在活跃状态。

GOMAXPROCS 默认为 CPU 核数，可以使用 `runtime.GOMAXPROCS` 修改。

### P

Processor 处理器是线程与 goroutine 之间的中间层，能够提供线程运行所需的上下文环境，也会负责调度线程上的任务队列。

调度器在启动时会创建 GOMAXPROCS 个处理器，所以处理器数量一定等于 GOMAXPROCS，这些处理器会绑定到不同的内核线程上。

P 的本地队列同全局队列类似，存放的也是等待运行的 G，但数量有限，最多不超过 256 个。新建 G 时，会优先加入到本地队列，如果本地队列已满，会把本地队列中一半的 G 移动到全局队列。

## 调度过程

1. 启动调度器；
2. 设置处理器数量，通过指针将线程 `m0` 与处理器 `p0` 绑定，将 `p0` 之外的处理器加入到全局空闲队列中；
3. 初始化 Goroutine 结构体，将结构体放到队列中，本地队列还有剩余空间时是处理器本地队列，本地队列没有剩余空间时是全局队列；
4. 调度循环：
   1. 当全局队列中有待执行的 Goroutine 时，保证有一定几率从全局运行队列中查找对应 Goroutine；
   2. 从处理器本地队列中查找 Goroutine；
   3. 阻塞地查找 Goroutine：
      1. 从本地队列、全局队列中查找 Goroutine；
      2. 从网络轮询器中查找 Goroutine；
      3. 尝试从其他随机的处理器中窃取待运行的 Goroutine。
