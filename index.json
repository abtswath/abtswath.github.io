[{"content":"1.18 之前 当前容量小于 1024 时，新容量为当前容量的两倍； 当前容量大于等于 1024 时，新容量为当前容量的 1.25 倍。 1.18之后 当前容量小于 256 时，新容量为当前容量两倍； 当前容量大于等于 256 时，新容量计算公式为 当前容量 + (当前容量 + 3 * 256) / 4。 https://github.com/golang/go/commit/2dda92ff6f9f07eeb110ecbf0fc2d7a0ddd27f9d https://groups.google.com/g/golang-nuts/c/UaVlMQ8Nz3o\n","permalink":"https://blog.abtswath.com/archives/go-growslice/","summary":"1.18 之前 当前容量小于 1024 时，新容量为当前容量的两倍； 当前容量大于等于 1024 时，新容量为当前容量的 1.25 倍。 1.18之后 当前容量小于 256 时，新容量为当前容量两倍； 当前容量大于等于 256 时，新容量计算公式为 当前容量 + (当前容量 + 3 * 256) / 4。 https://github.com/golang/go/commit/2dda92ff6f9f07eeb110ecbf0fc2d7a0ddd27f9d https://groups.google.com/g/golang-nuts/c/UaVlMQ8Nz3o","title":"Go 切片扩容"},{"content":"内存分配策略 链表空间分配器之隔离适应策略 将内存分为多个内存块相同的链表，分配内存时先找到符合要求的链表，再去链表中找到合适的内存块。\n多级缓存 线程缓存、中心缓存、页堆。32KB 以下的对象，选择线程缓存，线程缓存不能满足需求时，将对象分配到中心缓存；32KB 以上的对象，选择页堆。\n线程缓存属于每一个线程，不涉及多线程访问，不需要互斥锁；访问中心缓存需要互斥锁。\n内存分配 根据对象类型（微对象、小对象、大对象）不同，选择不同分配策略 微对象 (0, 16B) - 先使用微型分配器，再依次尝试线程缓存、中心缓存和堆分配内存。 小对象 (16B, 32KB) - 依次尝试使用线程缓存、中心缓存和堆分配内存。 大对象 (32KB,) - 直接在堆上分配内存。 微对象 使用线程缓存上的微分配器提高微对象分配的性能，主要用来分配较小的字符串以及逃逸的临时变量。将多个较小的内存分配合并到一个内存块上，直到内存块中所有的对象都需要被回收时，内存块才会被回收。\n微型分配器管理的对象不可以是指针类型。\n小对象 16B ~ 32KB 大小的对象以及小于 16B 的指针类型对象。首先确定分配对象的大小及跨度类，再依次从线程缓存、中心缓存或者堆中获取内存管理单元并从内存管理单元找到空闲的内存空间。\n大对象 计算该对象所需页数，按照 8KB 的倍数在堆上申请内存。\n垃圾回收 Go1.3 前的标记 - 清除算法 标记：从根对象出发查找并标记堆中所有存活的对象； 清除：遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。 缺点 需要 STW (Stop the world)，让程序暂停，程序出现卡顿； 需要扫描整个堆； 清除数据会产生堆碎片。 Go1.5 三色标记法 把对象分为白色、灰色、黑色三种类型 白色对象：潜在的垃圾对象，其内存可能会被回收； 黑色对象：活跃对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象； 灰色对象：活跃对象，存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象。 执行过程 从根节点遍历所有对象，从白色对象的集合中取出一个对象将其标记为灰色； 遍历灰色对象集合，从灰色集合中取出一个对象并将其引用的对象标记为灰色，将其本身标记为黑色； 重复第三步，直至灰色对象集合中无任何对象； 回收白色对象集合中所有的对象。 在并发或增量执行时如果 STW 会影响性能，否则会产生悬挂指针，即没有任何指针指向该对象，影响内存安全性。想要并发或增量标记对象需要使用屏障技术。\n屏障技术 三色标记混合写屏障 总结 Go1.3：普通标记清除法：逻辑简单，但启动时需要 STW，效率极低； Go1.5：三色标记法：堆空间启动写屏障，栈空间不启动，全部扫描之后，需要再次扫描栈空间（需要 STW），效率一般； Go1.8：三色标记混合写屏障：栈空间不启动，堆空间启动，几乎不用 STW，效率高。 ","permalink":"https://blog.abtswath.com/archives/go-memory-allocator/","summary":"内存分配策略 链表空间分配器之隔离适应策略 将内存分为多个内存块相同的链表，分配内存时先找到符合要求的链表，再去链表中找到合适的内存块。\n多级缓存 线程缓存、中心缓存、页堆。32KB 以下的对象，选择线程缓存，线程缓存不能满足需求时，将对象分配到中心缓存；32KB 以上的对象，选择页堆。\n线程缓存属于每一个线程，不涉及多线程访问，不需要互斥锁；访问中心缓存需要互斥锁。\n内存分配 根据对象类型（微对象、小对象、大对象）不同，选择不同分配策略 微对象 (0, 16B) - 先使用微型分配器，再依次尝试线程缓存、中心缓存和堆分配内存。 小对象 (16B, 32KB) - 依次尝试使用线程缓存、中心缓存和堆分配内存。 大对象 (32KB,) - 直接在堆上分配内存。 微对象 使用线程缓存上的微分配器提高微对象分配的性能，主要用来分配较小的字符串以及逃逸的临时变量。将多个较小的内存分配合并到一个内存块上，直到内存块中所有的对象都需要被回收时，内存块才会被回收。\n微型分配器管理的对象不可以是指针类型。\n小对象 16B ~ 32KB 大小的对象以及小于 16B 的指针类型对象。首先确定分配对象的大小及跨度类，再依次从线程缓存、中心缓存或者堆中获取内存管理单元并从内存管理单元找到空闲的内存空间。\n大对象 计算该对象所需页数，按照 8KB 的倍数在堆上申请内存。\n垃圾回收 Go1.3 前的标记 - 清除算法 标记：从根对象出发查找并标记堆中所有存活的对象； 清除：遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。 缺点 需要 STW (Stop the world)，让程序暂停，程序出现卡顿； 需要扫描整个堆； 清除数据会产生堆碎片。 Go1.5 三色标记法 把对象分为白色、灰色、黑色三种类型 白色对象：潜在的垃圾对象，其内存可能会被回收； 黑色对象：活跃对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象； 灰色对象：活跃对象，存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象。 执行过程 从根节点遍历所有对象，从白色对象的集合中取出一个对象将其标记为灰色； 遍历灰色对象集合，从灰色集合中取出一个对象并将其引用的对象标记为灰色，将其本身标记为黑色； 重复第三步，直至灰色对象集合中无任何对象； 回收白色对象集合中所有的对象。 在并发或增量执行时如果 STW 会影响性能，否则会产生悬挂指针，即没有任何指针指向该对象，影响内存安全性。想要并发或增量标记对象需要使用屏障技术。\n屏障技术 三色标记混合写屏障 总结 Go1.","title":"Go 内存管理"},{"content":"GMP模型 G Goroutine 是 Go 语言调度器中待执行的任务，类似操作系统中的线程，但占用内存低且上下文切换开销小。\nM Machine 指操作系统线程。调度器最多创建 10000 个线程，但最多只会有 GOMAXPROCS 个线程处在活跃状态。\nGOMAXPROCS 默认为 CPU 核数，可以使用 runtime.GOMAXPROCS 修改。\nP Processor 处理器是线程与 goroutine 之间的中间层，能够提供线程运行所需的上下文环境，也会负责调度线程上的任务队列。\n调度器在启动时会创建 GOMAXPROCS 个处理器，所以处理器数量一定等于 GOMAXPROCS，这些处理器会绑定到不同的内核线程上。\nP 的本地队列同全局队列类似，存放的也是等待运行的 G，但数量有限，最多不超过 256 个。新建 G 时，会优先加入到本地队列，如果本地队列已满，会把本地队列中一半的 G 移动到全局队列。\n调度过程 启动调度器； 设置处理器数量，通过指针将线程 m0 与处理器 p0 绑定，将 p0 之外的处理器加入到全局空闲队列中； 初始化 Goroutine 结构体，将结构体放到队列中，本地队列还有剩余空间时是处理器本地队列，本地队列没有剩余空间时是全局队列； 调度循环： 当全局队列中有待执行的 Goroutine 时，保证有一定几率从全局运行队列中查找对应 Goroutine； 从处理器本地队列中查找 Goroutine； 阻塞地查找 Goroutine： 从本地队列、全局队列中查找 Goroutine； 从网络轮询器中查找 Goroutine； 尝试从其他随机的处理器中窃取待运行的 Goroutine。 ","permalink":"https://blog.abtswath.com/goroutine/","summary":"GMP模型 G Goroutine 是 Go 语言调度器中待执行的任务，类似操作系统中的线程，但占用内存低且上下文切换开销小。\nM Machine 指操作系统线程。调度器最多创建 10000 个线程，但最多只会有 GOMAXPROCS 个线程处在活跃状态。\nGOMAXPROCS 默认为 CPU 核数，可以使用 runtime.GOMAXPROCS 修改。\nP Processor 处理器是线程与 goroutine 之间的中间层，能够提供线程运行所需的上下文环境，也会负责调度线程上的任务队列。\n调度器在启动时会创建 GOMAXPROCS 个处理器，所以处理器数量一定等于 GOMAXPROCS，这些处理器会绑定到不同的内核线程上。\nP 的本地队列同全局队列类似，存放的也是等待运行的 G，但数量有限，最多不超过 256 个。新建 G 时，会优先加入到本地队列，如果本地队列已满，会把本地队列中一半的 G 移动到全局队列。\n调度过程 启动调度器； 设置处理器数量，通过指针将线程 m0 与处理器 p0 绑定，将 p0 之外的处理器加入到全局空闲队列中； 初始化 Goroutine 结构体，将结构体放到队列中，本地队列还有剩余空间时是处理器本地队列，本地队列没有剩余空间时是全局队列； 调度循环： 当全局队列中有待执行的 Goroutine 时，保证有一定几率从全局运行队列中查找对应 Goroutine； 从处理器本地队列中查找 Goroutine； 阻塞地查找 Goroutine： 从本地队列、全局队列中查找 Goroutine； 从网络轮询器中查找 Goroutine； 尝试从其他随机的处理器中窃取待运行的 Goroutine。 ","title":"GMP 模型与调度过程"},{"content":"准备工作 Github 账号 Packagist 账号 创建 git 仓库 GitHub 创建仓库并克隆到本地。\ngit clone git@github.com:Great233/url.git composer 初始化 composer init 输入包名称、描述、作者、协议、依赖等信息，回车结束。最终会生成composer.json配置文件，文件内容如下：\n{ \u0026#34;name\u0026#34;: \u0026#34;abtswiath/url\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A library to parse URL, support parameters with the same name\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;library\u0026#34;, \u0026#34;require\u0026#34;: { \u0026#34;php\u0026#34;: \u0026#34;\u0026gt;=7.2\u0026#34; }, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;autoload\u0026#34;: { \u0026#34;psr-4\u0026#34;: { \u0026#34;Url\\\\\u0026#34;: \u0026#34;src/Url/\u0026#34; } }, \u0026#34;authors\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Great\u0026#34; } ], \u0026#34;require-dev\u0026#34;: { \u0026#34;phpunit/phpunit\u0026#34;: \u0026#34;^9.5\u0026#34; }, \u0026#34;support\u0026#34;: { \u0026#34;issues\u0026#34;: \u0026#34;https://github.com/Great233/url/issues\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;https://github.com/Great233/url\u0026#34; } } 提交代码至 Github 代码编写完成并且测试无误之后提交到 Github。\n以下步骤可选： 创建标签以标记版本，如：\ngit tag -a 1.0.0 -m \u0026#39;Release 1.0.0\u0026#39; 推送标签至 Github：\ngit push origin 1.0.0 Github 创建新的 Release 版本，版本号参考语义版本控制\n发布到Packagist 登录 Packagist，打开提交页面，输入 Github 存储库 URL，点击 Check 按钮检出仓库，系统会根据composer.json文件内容自动设置包的相关信息。 依赖包发布之后可设置自动更新，Packagist Settings 中按照说明操作即可。\n使用依赖包 发布到 Packagist 之后就可以在自己项目中安装该依赖包：\ncomposer require abtswiath/url 注： 如果没有创建标签发布版本，需要指定 dev：\ncomposer require \u0026#39;abtswiath/url @dev\u0026#39; ","permalink":"https://blog.abtswath.com/publish-composer-package-to-packagist/","summary":"准备工作 Github 账号 Packagist 账号 创建 git 仓库 GitHub 创建仓库并克隆到本地。\ngit clone git@github.com:Great233/url.git composer 初始化 composer init 输入包名称、描述、作者、协议、依赖等信息，回车结束。最终会生成composer.json配置文件，文件内容如下：\n{ \u0026#34;name\u0026#34;: \u0026#34;abtswiath/url\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A library to parse URL, support parameters with the same name\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;library\u0026#34;, \u0026#34;require\u0026#34;: { \u0026#34;php\u0026#34;: \u0026#34;\u0026gt;=7.2\u0026#34; }, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;autoload\u0026#34;: { \u0026#34;psr-4\u0026#34;: { \u0026#34;Url\\\\\u0026#34;: \u0026#34;src/Url/\u0026#34; } }, \u0026#34;authors\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Great\u0026#34; } ], \u0026#34;require-dev\u0026#34;: { \u0026#34;phpunit/phpunit\u0026#34;: \u0026#34;^9.5\u0026#34; }, \u0026#34;support\u0026#34;: { \u0026#34;issues\u0026#34;: \u0026#34;https://github.com/Great233/url/issues\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;https://github.com/Great233/url\u0026#34; } } 提交代码至 Github 代码编写完成并且测试无误之后提交到 Github。","title":"如何将自己的依赖包发布到 Composer Packagist"},{"content":"错误信息 [ERROR] Plugin org.apache.maven.plugins:maven-surefire-plugin:2.22.2 or one of its dependencies could not be resolved: Failed to read artifact descriptor for org.apache.maven.plugins:maven-surefire-plugin:jar:2.22.2: Could not transfer artifact org.apache.maven.surefire:surefire:pom:2.22.2 from/to aliyunmaven (https://maven.aliyun.com/repository/public): transfer failed for https://maven.aliyun.com/repository/public/org/apache/maven/surefire/surefire/2.22.2/surefire-2.22.2.pom: java.lang.RuntimeException: Unexpected error: java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty -\u0026gt; [Help 1] 截图如下 问题原因及解决方案 报错提示大致是https证书安全检查问题，以下是搜索引擎加自己尝试得出的一些解决方案：\n1. 使用 http 的镜像源，例如： \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;aliyunmaven\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; \u0026lt;name\u0026gt;阿里云公共仓库\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/repository/public\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; 此方案确实可以解决一部分问题，但还是有些 jar 包会出现同样的错误，具体原因未深究。\n2. 生成证书并导入到 jre security 中 首先到处 https 证书，然后使用 keytool 导入证书：\n$ cd \u0026lt;JAVA_HOME\u0026gt;\\jre\\lib\\security $ keytool -import -alias aliyun-maven -keystore cacerts -file path-to-aliyun-maven.cer 证书指纹changeit，输入 Y 表示确认。 重新打开 cmd 窗口，再次尝试安装依赖。 如果还是不行报错，参考https://www.techpaste.com/2017/03/trustanchors-parameter-must-non-empty/\n3. 替换 jdk 的 cacerts 文件 使用 openjdk 16 中的 cacerts（\u0026lt;JAVA_HOME\u0026gt;\\jre\\lib\\security\\cacerts） 文件替换 openjdk 8 中 cacerts 文件，替换前记得备份。\n我使用的是方案三，目前没发现任何问题。\n","permalink":"https://blog.abtswath.com/maven-invalid-algorithm-parameter-exception/","summary":"错误信息 [ERROR] Plugin org.apache.maven.plugins:maven-surefire-plugin:2.22.2 or one of its dependencies could not be resolved: Failed to read artifact descriptor for org.apache.maven.plugins:maven-surefire-plugin:jar:2.22.2: Could not transfer artifact org.apache.maven.surefire:surefire:pom:2.22.2 from/to aliyunmaven (https://maven.aliyun.com/repository/public): transfer failed for https://maven.aliyun.com/repository/public/org/apache/maven/surefire/surefire/2.22.2/surefire-2.22.2.pom: java.lang.RuntimeException: Unexpected error: java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty -\u0026gt; [Help 1] 截图如下 问题原因及解决方案 报错提示大致是https证书安全检查问题，以下是搜索引擎加自己尝试得出的一些解决方案：\n1. 使用 http 的镜像源，例如： \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;aliyunmaven\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; \u0026lt;name\u0026gt;阿里云公共仓库\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/repository/public\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; 此方案确实可以解决一部分问题，但还是有些 jar 包会出现同样的错误，具体原因未深究。\n2. 生成证书并导入到 jre security 中 首先到处 https 证书，然后使用 keytool 导入证书：","title":"openjdk 8 maven 下载项目依赖时遇到的问题"},{"content":"使用场景 分布式场景下保证同一时刻内只能有一个客户端对资源进行操作。\n保证分布式锁有效性及安全性的要求 互斥性：任何时刻只能有一个客户端持有锁。 可重入：总是可以获取锁，即使锁定资源的客户端崩溃，避免死锁。 高可用：只要大多数 Redis 节点已启动，客户端就可以获取锁和释放锁。 获取锁 以毫秒为单位获取当前时间戳。 以相同的键名和值尝试获取所有实例的锁。 客户端以当前时间减去开始获取锁的时间得到锁使用的时间。当大多数Redis节点（N/2+1）获取到锁并且锁使用时间小于锁的失效时间，锁才算获取成功。 如果获取到锁，锁的真正有效时间为步骤三计算结果。 如果获取锁失败，客户端应该在所有实例上进行解锁。 释放锁 向所有的 Redis 实例发送释放锁的命令，不用关心之前有没有成功获取到锁。\n","permalink":"https://blog.abtswath.com/redis-distributed-lock/","summary":"使用场景 分布式场景下保证同一时刻内只能有一个客户端对资源进行操作。\n保证分布式锁有效性及安全性的要求 互斥性：任何时刻只能有一个客户端持有锁。 可重入：总是可以获取锁，即使锁定资源的客户端崩溃，避免死锁。 高可用：只要大多数 Redis 节点已启动，客户端就可以获取锁和释放锁。 获取锁 以毫秒为单位获取当前时间戳。 以相同的键名和值尝试获取所有实例的锁。 客户端以当前时间减去开始获取锁的时间得到锁使用的时间。当大多数Redis节点（N/2+1）获取到锁并且锁使用时间小于锁的失效时间，锁才算获取成功。 如果获取到锁，锁的真正有效时间为步骤三计算结果。 如果获取锁失败，客户端应该在所有实例上进行解锁。 释放锁 向所有的 Redis 实例发送释放锁的命令，不用关心之前有没有成功获取到锁。","title":"Redis 分布式锁之 RedLock"}]