[{"content":"准备工作 Github 账号 Packagist 账号 创建 git 仓库 GitHub 创建仓库并克隆到本地。\ngit clone git@github.com:Great233/url.git composer 初始化 composer init 输入包名称、描述、作者、协议、依赖等信息，回车结束。最终会生成composer.json配置文件，文件内容如下：\n{ \u0026#34;name\u0026#34;: \u0026#34;abtswiath/url\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A library to parse URL, support parameters with the same name\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;library\u0026#34;, \u0026#34;require\u0026#34;: { \u0026#34;php\u0026#34;: \u0026#34;\u0026gt;=7.2\u0026#34; }, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;autoload\u0026#34;: { \u0026#34;psr-4\u0026#34;: { \u0026#34;Url\\\\\u0026#34;: \u0026#34;src/Url/\u0026#34; } }, \u0026#34;authors\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Great\u0026#34; } ], \u0026#34;require-dev\u0026#34;: { \u0026#34;phpunit/phpunit\u0026#34;: \u0026#34;^9.5\u0026#34; }, \u0026#34;support\u0026#34;: { \u0026#34;issues\u0026#34;: \u0026#34;https://github.com/Great233/url/issues\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;https://github.com/Great233/url\u0026#34; } } 提交代码至 Github 代码编写完成并且测试无误之后提交到 Github。\n以下步骤可选： 创建标签以标记版本，如：\ngit tag -a 1.0.0 -m \u0026#39;Release 1.0.0\u0026#39; 推送标签至 Github：\ngit push origin 1.0.0 Github 创建新的 Release 版本，版本号参考语义版本控制\n发布到Packagist 登录 Packagist，打开提交页面，输入 Github 存储库 URL，点击 Check 按钮检出仓库，系统会根据composer.json文件内容自动设置包的相关信息。 依赖包发布之后可设置自动更新，Packagist Settings 中按照说明操作即可。\n使用依赖包 发布到 Packagist 之后就可以在自己项目中安装该依赖包：\ncomposer require abtswiath/url 注： 如果没有创建标签发布版本，需要指定 dev：\ncomposer require \u0026#39;abtswiath/url @dev\u0026#39; ","permalink":"https://www.abtswath.com/publish-composer-package-to-packagist/","summary":"准备工作 Github 账号 Packagist 账号 创建 git 仓库 GitHub 创建仓库并克隆到本地。\ngit clone git@github.com:Great233/url.git composer 初始化 composer init 输入包名称、描述、作者、协议、依赖等信息，回车结束。最终会生成composer.json配置文件，文件内容如下：\n{ \u0026#34;name\u0026#34;: \u0026#34;abtswiath/url\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A library to parse URL, support parameters with the same name\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;library\u0026#34;, \u0026#34;require\u0026#34;: { \u0026#34;php\u0026#34;: \u0026#34;\u0026gt;=7.2\u0026#34; }, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;autoload\u0026#34;: { \u0026#34;psr-4\u0026#34;: { \u0026#34;Url\\\\\u0026#34;: \u0026#34;src/Url/\u0026#34; } }, \u0026#34;authors\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Great\u0026#34; } ], \u0026#34;require-dev\u0026#34;: { \u0026#34;phpunit/phpunit\u0026#34;: \u0026#34;^9.5\u0026#34; }, \u0026#34;support\u0026#34;: { \u0026#34;issues\u0026#34;: \u0026#34;https://github.com/Great233/url/issues\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;https://github.com/Great233/url\u0026#34; } } 提交代码至 Github 代码编写完成并且测试无误之后提交到 Github。","title":"如何将自己的依赖包发布到 Composer Packagist"},{"content":"错误信息 [ERROR] Plugin org.apache.maven.plugins:maven-surefire-plugin:2.22.2 or one of its dependencies could not be resolved: Failed to read artifact descriptor for org.apache.maven.plugins:maven-surefire-plugin:jar:2.22.2: Could not transfer artifact org.apache.maven.surefire:surefire:pom:2.22.2 from/to aliyunmaven (https://maven.aliyun.com/repository/public): transfer failed for https://maven.aliyun.com/repository/public/org/apache/maven/surefire/surefire/2.22.2/surefire-2.22.2.pom: java.lang.RuntimeException: Unexpected error: java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty -\u0026gt; [Help 1] 截图如下 问题原因及解决方案 报错提示大致是https证书安全检查问题，以下是搜索引擎加自己尝试得出的一些解决方案：\n1. 使用 http 的镜像源，例如： \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;aliyunmaven\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; \u0026lt;name\u0026gt;阿里云公共仓库\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/repository/public\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; 此方案确实可以解决一部分问题，但还是有些 jar 包会出现同样的错误，具体原因未深究。\n2. 生成证书并导入到 jre security 中 首先到处 https 证书，然后使用 keytool 导入证书：\n$ cd \u0026lt;JAVA_HOME\u0026gt;\\jre\\lib\\security $ keytool -import -alias aliyun-maven -keystore cacerts -file path-to-aliyun-maven.cer 证书指纹changeit，输入 Y 表示确认。 重新打开 cmd 窗口，再次尝试安装依赖。 如果还是不行报错，参考https://www.techpaste.com/2017/03/trustanchors-parameter-must-non-empty/\n3. 替换 jdk 的 cacerts 文件 使用 openjdk 16 中的 cacerts（\u0026lt;JAVA_HOME\u0026gt;\\jre\\lib\\security\\cacerts） 文件替换 openjdk 8 中 cacerts 文件，替换前记得备份。\n我使用的是方案三，目前没发现任何问题。\n","permalink":"https://www.abtswath.com/maven-invalid-algorithm-parameter-exception/","summary":"错误信息 [ERROR] Plugin org.apache.maven.plugins:maven-surefire-plugin:2.22.2 or one of its dependencies could not be resolved: Failed to read artifact descriptor for org.apache.maven.plugins:maven-surefire-plugin:jar:2.22.2: Could not transfer artifact org.apache.maven.surefire:surefire:pom:2.22.2 from/to aliyunmaven (https://maven.aliyun.com/repository/public): transfer failed for https://maven.aliyun.com/repository/public/org/apache/maven/surefire/surefire/2.22.2/surefire-2.22.2.pom: java.lang.RuntimeException: Unexpected error: java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty -\u0026gt; [Help 1] 截图如下 问题原因及解决方案 报错提示大致是https证书安全检查问题，以下是搜索引擎加自己尝试得出的一些解决方案：\n1. 使用 http 的镜像源，例如： \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;aliyunmaven\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; \u0026lt;name\u0026gt;阿里云公共仓库\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/repository/public\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; 此方案确实可以解决一部分问题，但还是有些 jar 包会出现同样的错误，具体原因未深究。\n2. 生成证书并导入到 jre security 中 首先到处 https 证书，然后使用 keytool 导入证书：","title":"openjdk 8 maven 下载项目依赖时遇到的问题"},{"content":"使用场景 分布式场景下保证同一时刻内只能有一个客户端对资源进行操作。\n保证分布式锁有效性及安全性的要求 互斥性：任何时刻只能有一个客户端持有锁。 可重入：总是可以获取锁，即使锁定资源的客户端崩溃，避免死锁。 高可用：只要大多数 Redis 节点已启动，客户端就可以获取锁和释放锁。 获取锁 以毫秒为单位获取当前时间戳。 以相同的键名和值尝试获取所有实例的锁。 客户端以当前时间减去开始获取锁的时间得到锁使用的时间。当大多数Redis节点（N/2+1）获取到锁并且锁使用时间小于锁的失效时间，锁才算获取成功。 如果获取到锁，锁的真正有效时间为步骤三计算结果。 如果获取锁失败，客户端应该在所有实例上进行解锁。 释放锁 向所有的 Redis 实例发送释放锁的命令，不用关心之前有没有成功获取到锁。\n","permalink":"https://www.abtswath.com/redis-distributed-lock/","summary":"使用场景 分布式场景下保证同一时刻内只能有一个客户端对资源进行操作。\n保证分布式锁有效性及安全性的要求 互斥性：任何时刻只能有一个客户端持有锁。 可重入：总是可以获取锁，即使锁定资源的客户端崩溃，避免死锁。 高可用：只要大多数 Redis 节点已启动，客户端就可以获取锁和释放锁。 获取锁 以毫秒为单位获取当前时间戳。 以相同的键名和值尝试获取所有实例的锁。 客户端以当前时间减去开始获取锁的时间得到锁使用的时间。当大多数Redis节点（N/2+1）获取到锁并且锁使用时间小于锁的失效时间，锁才算获取成功。 如果获取到锁，锁的真正有效时间为步骤三计算结果。 如果获取锁失败，客户端应该在所有实例上进行解锁。 释放锁 向所有的 Redis 实例发送释放锁的命令，不用关心之前有没有成功获取到锁。","title":"Redis 分布式锁之 RedLock"}]